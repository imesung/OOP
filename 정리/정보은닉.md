## 정보은닉

**정보은닉은 한마디로 정의하면 무엇일까?**

>  **공통된 정보를 모아놓되 구체적인 정보를 숨겼다.**

예를 통해 살펴보면, 바람둥이의 연애 편지를 볼 수 있다.

제비라는 인물은 유명한 바람둥이이다. 또한, 글 솜씨가 매우 뛰어나 편지로 여성들의 마음을 울리는 경향이 있는데, 5명에게 편지를 보내면 5명 모두 호감을 느낄 정도이다.

이 때, 제비라는 인물은 과연 모든 편지를 다르게 썼을까? 아니다.. 같은 내용으로 편지를 만들고 이름 또한 쓰지 않는 것이다. **즉, 정보은닉을 통해 5명의 여성들의 마음을 훔친 것이다.**



**진짜 객체지향**

진짜 객체지향은 정보은닉에서부터 시작된다.

객체지향적인 구조를 통해서 얻고자 하는 것이 유연성이라면 정보은닉은 그것을 가능하게 한 전략이다.

**객체, 상속, 캡슐화 등은 정보은닉의 수단에 불과하며, 좋은 정보은닉은 잘 된 추상화를 통해 얻어진다.**



**정보은닉의 정의**

소프트웨어의 유연성을 확보하는 단 한가지 방법 - 객체 간에 서로를 모르게 하는 것

두 객체가 서로를 모른다는 것은 서로의 코드에 상대 객체나 클래스에 대한 코드가 단 한 줄도 없다는 의미이다. 이 말은 즉슨 두 객체 중 어느 하나가 수정되거나 사라지더라도 다른 객체는 영향을 받지 않는 다는 것이다.

하지만, 객체지향언어의 특성상 어떤 목적을 달성하기 위해서는 다른 객체와의 협력이 있어야 하기 때문에 객체간의 관계는 이루어져야 한다. 즉, 우리는 관계를 아예 분리하는 것이 아니라, **좋은 관계를 맺어야한다는 것이다.**

그렇다면 좋은 관계는 어떤 것일까?

	1. 자주 변경될 가능성이 있는 것에는 의존하지 않는다.
 	2. 외부로 노출된 메소드를 최소한으로 줄인다.
     - 노출된 메소드가 최소인 객체는 노출된 메소드가 많은 객체에 비해 메소드가 적게 호출되고, 이는 다른 객체의 영향을 받을 가능성을 줄이는 것이다.
	3. 객체의 책임을 최소한으로 줄인다.
    - 책임이 작은 객체는 다른 객체와의 관계가 작아지고 책임이 작아진 객체는 수정될 가능성도 줄어든다. 따라서, 해당 객체 수정에 의한 다른 객체의 영향을 줄일 수 있다.



**정보은닉의 종류**

- 객체의 구체적인 타입 은닉(= 상위 타입 캐스팅)
- 객체의 필드 및 메소드 은닉(= 캡슐화)
- 구현 은닉(= 인터페이스 및 추상 클래스 기반의 구현)



**정보은닉의 목적**

- 코드가 구체적인 것들(타입, 메소드, 구현)에 의존하는 것을 막아줌으로써 **객체간의 구체적인 결합도를 약화시켜 기능의 교체나 변경이 쉽도록 한다.**
- 동일한 타입의 다른 구현 객체들을 교체함으로써 동적 기능 변경이 가능하다.
  - 하나의 타입의 상황에 맞는 여러 구현 객체들을 둔다.
- 연동할 구체적인 구현이 없는 상태에서도(인터페이스 만으로) 정확한 연동 코드의 생성이 가능하다.
  - 외부에서 인터페이스만 보고 기능에 따른 로직 구현이 가능하다.



**객체 생성 시 정보은닉**

~~~java
class Rectangle{
  public void rectangle() {
    System.out.println("rectangle");
  }

  public static void main(String [] args) {
    Rectangle rectangle = new Rectangle();	//코드 1
    rectangle.rectangle();	//Rectangle 클래스에 의존적인 코드
  }
}
~~~

- 코드 1은 Rectangle 클래스를 변수로 참조 받아서 Rectangle의 모든 메소드를 사용할 수 있게 된다.



- 이제, Rectangle과 유사한 기능인 Circle을 추가해보자.
  - 이 때는, Rectangle과 Circle의 추상화한 Shape라는 추상 클래스를 생성하여 공통부분은 여기로 빼내는 것이다.

~~~java
abstract class Shape{
    abstract public void draw();
}

class Rectangle extends Shape{
    public void draw(){ rectangle();}   
    public void rectangle(){ System.out.println("rectangle"); }
}

public static void main(String[] args) {
    Shape shape = new Rectangle();	//코드 2
    shape.draw();  // Shape 클래스에 의존적인 코드
}
~~~

- 코드 2는 코드 1과 동일하게 Rectangle을 생성하였지만, 상위 타입인 Shape 클래스 참조 변수인 shape로 객체를 참조했다.
- 이로 인해, shape 참조 변수를 통해 사용할 수 있는 메소드는 Shape 클래스의 메소드로만 제한된다. 그래서 생성 이후 Rectangle 클래스와 관련된 어떤 메소드도 호출되지 않는 것이다. **이것이 바로 구체적인 타입 은닉에 해당된다.**
- 이를 통해서 얻을 수 있는 이점
  - Rectangle 생성 코드 이후에는 어떤 코드도 Rectangle 클래스에 의존하지 않는다.
  - 따라서 Rectangle 대신 Circle을 사용하고 싶을 시 Rectangle 대신 Circle을 생성하도록 변경하기만 하면 되는 것이다.



**팩토리 메소드 패턴을 이용한 타입 은닉**

~~~java
class ShapeFactory{
  public Shape createRectangle(){ return new Rectangle(); }
  public Shape createCircle(){ return new Circle(); }
}

public static void main(String[] args) {
  ShapeFactory factory = new ShapeFactory();
  Shape shape = factory.createCircle();
  shape.draw();
}
~~~

- ShapeFactory 클래스는 Rectangle과 Circle 객체를 생성하는 책임을 가지고 있고, 리턴하는 타입은 동일하게 Shape로 리턴한다.
- 이것에 대한 효과는, main()에서 ShapeFactory를 통해 Rectangle 혹은 Circle 객체를 생성하는데, ShapeFactory는 그저 createReactangle()과  createCircle()의 리턴 타입인 Shape만 알고 있고, Rectangle 클래스나 Circle 클래스는 전혀 알지 못한다. 따라서, **ShapeFactory를 이용해서 객체를 생성하면 생성된 이후의 모든 코드와 Rectangle 또는 Circle 클래스와는 전혀 무관한 코드가 되는 것이다.**
- 이것에 대한 장점은, 객체의 교체나 변경이 쉬워지고, 또 다른 Shape 타입을 추가하는 것이 쉬워진다. 즉, triangle같은 도형도 손쉽게 추가할 수 있는 것이다. **main을 변경하지 않아도!!**



**캡슐화를 통한 정보은닉**

많이들 알고 있듯이, 변수에 대한 캡슐화는 변수에 private 키워드를 이용해서 외부의 노출을 줄여 외부에서 임의로 접근하는 경우를 막는 것이다.

그렇다면 메소드에 대한 캡슐화는 어떨까?

~~~java
class Process{
  public void init(){}
  public void process(){}
  public void release(){}
}
~~~

일단 해당 소스의 메소드들은 모두 public으로 선언되어 있는데, 이렇게 하면 문제가 발생할 수 있는 점이 세가지 정도 있다.

1. 메소드의 호출 순서를 제대로 알지 못하면 원하는 결과값이 안 나타날 수 있다.
2. 구현의 구체적인 사항을 외부에 노출시킨다.
   - Process의 세부 단계에 대해서 외부 객체들이 알게 됨으로서 구현을 유추할 수 있다.
3. 어떤 메소드가 중요한 메소드인지 알 수 없다.
   - 적절한 수준에서 정보를 숨겨주어 객체를 이해하는 입장에 도움을 주어야하는데, 모든 메소드가 노출되어 있으면 무엇이 중요한지 알 수 없다.

~~~java
class Process{
  private void init(){}
  private void process(){}
  private void release(){}
  public void work(){
    init();
    process();
    release();
  }
} 
~~~

해당 소스는 이전에 public으로 선언되어있던 메소드들이 모두 private으로 선언되어 있고, work()를 통해 해당 메소드들을 호출하고 있다.

이틀 통해 얻을 수 있는 장점은,

1. 적절한 수준에서 메소드들이 공개와 비공개로 나누어져 있어 어떤 메소드를 우선 살펴야할 지 알 수 있다.
   - private 먼저
2. 개별 메소드들의 호출 순서를 work() 메소드에서 정의해주고 있어 Process 객체 사용에 대한 정보를 더 적게 알아도 된다.
3. work() 메소드만 노출되어 있으므로 Process 객체가 하는 일의 세부 내용을 덜 노출시킨다.
   - 즉, 외부에서는 Process 개체가 init - process - release 단계를 거친다는 점을 알 수가 없다. 그저 work()만 호출하고 있으니..



**오직 인터페이스에만 의존하도록 한다.**

인터페읏와 구현 클래스를 분리하여 외부에는 인터페이스만 제공하는 것이다. 이렇게 되면, 객체를 사용하는 입장에서는 인터페이스에만 의존하여 인터페이스가 공개하는 메소드들을 활용하여 본인들 입맛에 맞는 로직을 구현하는 것이다.

이 처럼 인터페이스와 구현을 분리하면,

1. Interface만으로 객체를 다룰 수 있어 구체적인 구현에 대해서 전혀 모르더라도 동작이 가능한 것이다. 즉, 구현에 대해 관심을 둘 필요가 없다.
2. 모든 클래스들이 오직 Interface에만 의존하게 되므로 추 후에 구현 객체를 다른 객체로 교환하거나 새로 만들어서 기능의 확장이 가능해진다.

이런 인터페이스의 장점을 이용한 대표적인 디자인 패턴은,

1. State 패턴 : 상태를 객체화하고, 인터페이스를 통해 상태화 된 객체를 지칭하게 함으로써, 상태가 추가되기 용이하다.
2. Bridge 패턴 : 연관관계가 있는 두 부류의 객체들을 **두 개의 인터페이스 간의 연관관계로 바꾸고, 구체적인 객체들을 인터페이스 상속을 통해 구현**함으로써, 각 부류의 객체들에 추가/삭제가 발생하더라도 다른쪽 부류에는 영향을 미치지 않도록 한다
3. Strategy 패턴 : 기능을 담은 객체를 인자로 넘겨 줌으로써 이를 받는 객체의 기능이 변경될 수 있도록 한다.
   - 인터페이스와 구현 객체가 따로 있고, 객체를 사용하는 입장은 인터페이스를 의존한다.
4. Observer 패턴 : 관찰자 객체들을 인터페이스로 추상화하고, 관찰 대상 객체에 이벤트가 발생했을 때 인터페이스만을 활용하여 이벤트를 전달함으로써 관찰자와 관찰 대상간의 구체적인 결합을 제거한다.



**정보은닉은 객체지향 언어의 목표이다.**

기능을 간편하게 수정/추가/교체가 가능하게 하는 것이 객체지향 언어의 목표이다. 이런 객체지향 언어가 기능의 수정/추가/교체를 가능하게 하기 위해 세운 **기초 전략이 바로 정보은닉**이다.

객체지향 언어를 통해 만들어진 좋은 설계, 즉 디자인 패턴과 같이 좋은 설계를 대표할만한 것들은 모두 정보은닉 기법을 적어도 일부를 활용하고 있거나, 전적으로 정보은닉을 통해 이득을 얻기 위해 만들어진 것들이다.

또한, 객체지향이 만들어낸 여러 개념들과 언어적 특성들 중 대부분은 정보 은닉을 위해 만들어진것이다.

상속을 통해 받을 수 있는 것 중 가장 중요한 것은 타입이며, 이를 통해 하위 객체가 상위 클래스로 지칭될 수 있다. **이것은 정보은닉을 가져오고 개쳋지향의 모든 이점을 가져오는 것이다.**